# Анализ сложности алгоритмов

## Big O Notation

Описывает верхнюю границу роста времени/памяти алгоритма при увеличении входных данных.

| Сложность | Название | Пример |
|-----------|----------|--------|
| O(1) | Константная | Доступ по индексу, хеш-таблица |
| O(log n) | Логарифмическая | Бинарный поиск |
| O(n) | Линейная | Линейный поиск, обход массива |
| O(n log n) | Линейно-логарифмическая | Merge sort, heap sort |
| O(n²) | Квадратичная | Bubble sort, вложенные циклы |
| O(2ⁿ) | Экспоненциальная | Перебор всех подмножеств |
| O(n!) | Факториальная | Перестановки |

## Порядок роста

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
```

## Правила вычисления

1. **Константы отбрасываются:** O(2n) → O(n)
2. **Доминирующий член:** O(n² + n) → O(n²)
3. **Последовательные операции складываются:** O(n) + O(m) = O(n + m)
4. **Вложенные операции перемножаются:** O(n) * O(m) = O(n * m)

## Примеры анализа

### Линейный поиск — O(n)

```go
func find(arr []int, target int) int {
    for i, v := range arr {  // цикл по n элементам
        if v == target {
            return i
        }
    }
    return -1
}
```

### Бинарный поиск — O(log n)

```go
func binarySearch(arr []int, target int) int {
    lo, hi := 0, len(arr)-1
    for lo <= hi {           // каждый шаг делит пространство пополам
        mid := lo + (hi-lo)/2
        switch {
        case arr[mid] == target:
            return mid
        case arr[mid] < target:
            lo = mid + 1
        default:
            hi = mid - 1
        }
    }
    return -1
}
```

### Два вложенных цикла — O(n²)

```go
func hasDuplicate(arr []int) bool {
    for i := 0; i < len(arr); i++ {
        for j := i + 1; j < len(arr); j++ {  // вложенный цикл
            if arr[i] == arr[j] {
                return true
            }
        }
    }
    return false
}
```

## Amortized complexity

Средняя стоимость операции за серию. Пример: `append` в Go — обычно O(1), но при расширении слайса O(n). Амортизированно — O(1).

## Space complexity

| Структура | Память |
|-----------|--------|
| Массив | O(n) |
| Hash map | O(n) |
| Рекурсия глубины d | O(d) — стек вызовов |
| Merge sort | O(n) — дополнительный массив |
| Quick sort | O(log n) — стек рекурсии |
| BFS | O(n) — очередь |

## Сложность операций стандартных структур

| Структура | Access | Search | Insert | Delete |
|-----------|--------|--------|--------|--------|
| Array | O(1) | O(n) | O(n) | O(n) |
| Linked List | O(n) | O(n) | O(1) | O(1) |
| Hash Table | — | O(1)* | O(1)* | O(1)* |
| BST (сбалансированное) | — | O(log n) | O(log n) | O(log n) |
| Heap | — | O(n) | O(log n) | O(log n) |

*амортизированно, worst case O(n) при коллизиях
